<!DOCTYPE html>

<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
  </head>

  <style>
    :root {
      --color-text: #bfbdb6;
      --color-background: #10141c;
      --color-background2: #30343c;
      --color-border: #474d56;
      --color-error:  #f26d78;
      --color-selected: #670033;
    }

    input {
      color: inherit;
      background-color: inherit;
    }

    input:focus {
      color: inherit;
      background-color: inherit;
    }

    /* Scrollbars */
    ::-webkit-scrollbar {
      width: 15px;
    }

    ::-webkit-scrollbar-track,
    ::-webkit-scrollbar-corner {
      background: var(--color-background);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--color-border);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--color-selected);
    }

    html,
    html * {
      scrollbar-color: var(--color-border) var(--color-background);
      scrollbar-width: thin;
    }
  </style>

  <body
    style="
      background-color: var(--color-background);
      color: var(--color-text);
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    "
  >
    <div id="main" style="display: flex;"></div>
  </body>

  <script type="module">

//
// SECTION Utilities
//

const formatDate = (date) => {
  let result = date.toISOString().slice(0, 10)
  return result
}

const notNU = (val) => {
  let reuslt = val !== null && val !== undefined
  return result
}

const isObject = (val) => {
  let result = val && typeof val === 'object' && val.constructor === Object
  return result
}

const getScrollbarWidths = () => {
  let outer = createEl('div');
  outer.style.visibility = "hidden";
  outer.style.overflowY = "scroll";
  document.body.appendChild(outer);

  let inner = createEl('div');
  outer.appendChild(inner);

  let scrollbarWidthV = (outer.offsetWidth - inner.offsetWidth);
  outer.removeChild(inner)

  outer.style.overflowY = "hidden"
  outer.style.overflowX = "scroll"

  outer.appendChild(inner)
  let scrollbarWidthH = outer.offsetHeight - inner.offsetHeight

  outer.parentNode.removeChild(outer);
  return [scrollbarWidthH, scrollbarWidthV];
}

const fieldsArePresent = (obj, colnames) => {
  let result = true
  let missingColnames = []
  for (let colname of colnames) {
    if (obj[colname] === undefined) {
      result = false
      missingColnames.push(colname)
    }
  }
  if (!result) {
    console.error(`fields ${missingColnames.join(",")} not present in`, obj)
  }
  return result
}

const arrSum = (arr) => {
  let result = 0
  for (let val of arr) {
    result += val
  }
  return result
}

const arrLinSearch = (arr, item) => {
  let result = -1
  for (let index = 0; index < arr.length; index += 1) {
    let elem = arr[index]
    if (elem == item) {
      result = index
      break
    }
  }
  return result
}

const arrRemoveIndex = (arr, index) => {
  arr.splice(index, 1)
}

const seq = (start, step, count) => {
  let result = [start]
  for (let i = 1; i < count; i += 1) {
    result.push(start + i * step)
  }
  return result
}

const dateSeq = (start, step, count) => {

  let result = []

  let startDate = new Date(start)
  let startDayIndex = startDate.getDate()

  for (let i = 0; i < count; i++) {
    let newDayIndex = startDayIndex + step * i
    let newDate = new Date(startDate)
    newDate.setDate(newDayIndex)
    result.push(newDate)
  }

  return result
}

const summarise = (data, groups, defaultCounts, filter, getKey, addRow) => {
  let groupedCounts = {}
  if (groups.length === 0) {
    groupedCounts = {total: {...defaultCounts}}
  }

  for (let row of data) {
    if (filter(row)) {

      if (groups.length === 0) {
        addRow(row, groupedCounts.total)
      }

      let currentGroupCount = groupedCounts
      for (let groupIndex = 0; groupIndex < groups.length; groupIndex += 1) {
        let group = groups[groupIndex]
        let key = getKey(row, group)

        if (groupIndex == groups.length - 1) {
          if (currentGroupCount[key] === undefined) {
            currentGroupCount[key] = {...defaultCounts}
          }
          addRow(row, currentGroupCount[key])
        } else {
          if (currentGroupCount[key] === undefined) {
            currentGroupCount[key] = {}
          }
          currentGroupCount = currentGroupCount[key]
        }
      }
    }
  }

  return groupedCounts
}

const flattenMap = (map, existing) => {
  let result = []
  for (let key of Object.keys(map)) {
    let nested = map[key]
    let newExisting = [...existing]
    newExisting.push(key)
    if (isObject(nested) && isObject(Object.values(nested)[0])) {
      result = result.concat(flattenMap(nested, newExisting))
    } else {
      for (let val of Object.values(nested)) {
        newExisting.push(val)
      }
      result.push(newExisting)
    }
  }
  return result
}

//
// SECTION DOM
//

const createEl = (name) => document.createElement(name)
const createDiv = () => createEl("div")

const createTextline = (line) => {
  let div = createDiv()
  div.innerHTML = line
  return div
}

const addEl = (parent, el) => {
  parent.appendChild(el)
  return el
}

const addDiv = (parent) => addEl(parent, createDiv())
const addTextline = (parent, line) => addEl(parent, createTextline(line))

const removeChildren = (element) => {
  while (element.lastChild) {
    element.removeChild(element.lastChild)
  }
}

const replaceChildren = (parent, newChild) => {
  removeChildren(parent)
  addEl(parent, newChild)
}

const createSwitch = (init, opts, onUpdate) => {
  let switchElement = createDiv()
  let currentSel = init
  let multiple = Array.isArray(init)

  const isSelected = (opt) => {
    let result = (!multiple && opt === currentSel) ||
      (multiple && arrLinSearch(currentSel, opt) !== -1)
    return result
  }

  for (let opt of opts) {
    let optElement = createDiv()
    switchElement.appendChild(optElement)

    let baseStyle = "padding-top: 5px; padding-bottom: 5px; cursor: pointer;"
    let hoverStyle = baseStyle + "background-color: var(--color-background2);"
    let selectedStyle = baseStyle + "background-color: var(--color-selected);"

    if (isSelected(opt)) {
      optElement.setAttribute("style", selectedStyle)
    } else {
      optElement.setAttribute("style", baseStyle)
    }

    optElement.addEventListener("mouseover", (event) => {
      if (!isSelected(opt)) {
        optElement.setAttribute("style", hoverStyle)
      }
    })
    optElement.addEventListener("mouseout", (event) => {
      if (!isSelected(opt)) {
        optElement.setAttribute("style", baseStyle)
      }
    })

    optElement.addEventListener("click", async (event) => {
      if (!multiple && opt !== currentSel) {

        for (let child of switchElement.childNodes) {
          child.setAttribute("style", baseStyle)
        }
        optElement.setAttribute("style", selectedStyle)
        currentSel = opt
        onUpdate(opt)

      } else if (multiple) {

        let optIndex = arrLinSearch(currentSel, opt)
        if (optIndex !== -1) {
          optElement.setAttribute("style", baseStyle)
          arrRemoveIndex(currentSel, optIndex)
        } else {
          optElement.setAttribute("style", selectedStyle)
          currentSel.push(opt)
        }
        onUpdate(currentSel)

      }
    })

    optElement.innerHTML = opt
  }

  return switchElement
}

const TABLE_ROW_HEIGHT_PX = 30
const SCROLLBAR_WIDTHS = getScrollbarWidths()

const tableContainerStyle = (widthPx) => {
  let result = "height: calc(100vh - " + SCROLLBAR_WIDTHS[0] +
  "px); overflow-x: hidden; overflow-y: scroll; width: "
  + (widthPx + SCROLLBAR_WIDTHS[1]) +
  "px; display: flex; justify-content: center; flex-shrink: 0;"
  return result
}

const tableContentStyle = (widthPx, rowCount) => {
  let result = "width: " + widthPx + "px; height: " + (rowCount * TABLE_ROW_HEIGHT_PX) + "px;"
  return result
}

const createTableCellElement = (widthPx) => {
  let cellElement = createDiv()
  cellElement.style.display = "flex"
  cellElement.style.width = widthPx + "px"
  cellElement.style.alignItems = "center"
  cellElement.style.justifyContent = "center"
  return cellElement
}

const createTableCellStringElement = (widthPx, string) => {
  let cellElement = createTableCellElement(widthPx)
  if (string !== undefined && string != null) {
    cellElement.innerHTML = string
  }
  return cellElement
}

const createTableRowElement = () => {
  let rowElement = createDiv()
  rowElement.style.display = "flex"
  rowElement.style.height = TABLE_ROW_HEIGHT_PX + "px"
  return rowElement
}

const createTableTitleElement = (title, downloadable) => {
  let titleElement = createDiv()
  titleElement.style.display = "flex"
  titleElement.style.alignItems = "center"
  titleElement.style.justifyContent = "center"
  titleElement.style.backgroundColor = "var(--color-background2)"
  titleElement.innerHTML = title

  if (downloadable) {
    titleElement.style.cursor = "pointer"
    titleElement.innerHTML += " â‡“ (download)"

    titleElement.addEventListener("click", (event) => {
      let csv = DOWNLOAD_CSV[title]
      if (csv) {
        let hidden = createEl("a")
        hidden.href = "data:text/csv;charset=utf-8," + encodeURI(csv)
        hidden.target = "_blank"
        hidden.download = title + ".csv"
        hidden.click()
      } else {
        console.error(`table '${title}' does not have a csv to download`)
      }
    })
  }

  return titleElement
}

const createTableHeaderRowElement = (colnames, colWidthsPx) => {
  let headerRow = createTableRowElement()
  headerRow.style.backgroundColor = "var(--color-border)"
  headerRow.style.position = "sticky"
  headerRow.style.top = "0"

  for (let colname of colnames) {
    let colWidthPx = colWidthsPx[colname]
    if (colWidthPx === undefined) {
      colWidthPx = colWidthsPx.default
    }
    let headerElement = createTableCellElement(colWidthPx)
    headerRow.appendChild(headerElement)
    headerElement.innerHTML = colname
  }

  return headerRow
}

const createTableDataRowElement = (rowIndex) => {
  let rowElement = createTableRowElement()
  rowElement.style.backgroundColor = "var(--color-background)"
  if (rowIndex % 2 == 1) {
    rowElement.style.backgroundColor = "var(--color-background2)"
  }
  return rowElement
}

const createTableElementFromSoa = (soa, formatters, colWidthsPx, title) => {

  let table = createDiv()
  let titleElement = addEl(table, createTableTitleElement(title, true))
  DOWNLOAD_CSV[title] = ""

  let colnames = Object.keys(soa)
  for (let colname of colnames) {
    DOWNLOAD_CSV[title] += colname + ","
  }
  DOWNLOAD_CSV[title] += "\n"

  let tableWidthPx = 0
  for (let colname of colnames) {
    if (colWidthsPx[colname] !== undefined) {
      tableWidthPx += colWidthsPx[colname]
    } else {
      tableWidthPx += colWidthsPx.default
    }
  }

  if (colnames.length > 0) {

    let headerRow = addEl(table, createTableHeaderRowElement(colnames, colWidthsPx))

    let rowCount = soa[colnames[0]].length
    table.setAttribute("style", tableContentStyle(tableWidthPx, rowCount))

    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      let rowElement = createTableDataRowElement(rowIndex)
      table.appendChild(rowElement)

      for (let colname of colnames) {
        let colData = soa[colname][rowIndex]
        let formatter = formatters[colname]
        if (formatter === undefined) {
          formatter = formatters.default
        }
        let colDataFormatted = formatter(colData)

        let colWidthPx = colWidthsPx[colname]
        if (colWidthPx === undefined) {
          colWidthPx = colWidthsPx.default
        }
        let cellElement = createTableCellStringElement(colWidthPx, colDataFormatted)
        rowElement.appendChild(cellElement)

        DOWNLOAD_CSV[title] += colDataFormatted + ","
      }

      DOWNLOAD_CSV[title] += "\n"
    }
  }

  return {table: table, width: tableWidthPx}
}

const initPassword = () => {
  let container = createDiv()
  let label = addDiv(container)
  let input = addEl(container, createEl("input"))
  let button = addDiv(container)
  let buttonText = addDiv(button)
  let errorText = addDiv(container)

  input.type = "password"
  input.style.width = "75vw"
  input.style.height = "2em"

  label.innerHTML = "Password"
  buttonText.innerHTML = "Submit"

  container.style.width = "75vw"
  container.style.margin = "auto"
  container.style.marginTop = "5vh"

  button.style.cursor = "pointer"
  button.style.border = "1px solid var(--color-border)"
  button.style.height = "50px"
  button.style.width = "50%"
  button.style.margin = "auto"
  button.style.marginTop = "10px"
  button.style.display = "flex"
  button.style.alignItems = "center"
  button.style.justifyContent = "center"

  errorText.style.color = "var(--color-error)"
  errorText.style.textAlign = "center"
  errorText.style.marginTop = "10px"

  button.addEventListener("click", async (e) => {
    if (buttonText.innerHTML !== "...") {
      errorText.innerHTML = ""
      if (input.value === "") {
        errorText.innerHTML = "Password is empty"
      } else {
        buttonText.innerHTML = "..."
        let updateSuccess = await updateData(input.value)
        if (!updateSuccess) {
          errorText.innerHTML = "Not recognized"
        } else {
          localStorage.setItem("password", input.value)
          switchToData(globalState.currentDataPage)
        }
        buttonText.innerHTML = "Submit"
      }
    }
  })

  return container
}

const initLoading = () => {
  let loading = createDiv()
  loading.style.fontSize = "40px"
  loading.style.display = "flex"
  loading.style.alignItems = "center"
  loading.style.justifyContent = "center"
  loading.style.height = "100vh"
  loading.style.margin = "auto"
  loading.innerHTML = "Loading..."
  return loading
}

const initSidebar = (widthPx, initSelected) => {
  let sidebar = createDiv()
  sidebar.style.width = widthPx + "px"
  sidebar.style.height = "100vh"
  sidebar.style.flexShrink = 0
  sidebar.style.display = "flex"
  sidebar.style.flexDirection = "column"
  sidebar.style.justifyContent = "space-between"
  sidebar.style.overflowX = "hidden"

  let top = addDiv(sidebar)

  let dataPages = {
    weeklySurveys: {name: "Weekly surveys"},
    bleeds: {name: "Bleeds"},
    counts: {name: "Counts"},
  }

  let linksContainer = addDiv(top)

  for (let [dest, props] of Object.entries(dataPages)) {
    let name = props.name

    let link = addDiv(linksContainer)
    link.innerHTML = name

    link.style.paddingTop = "5px"
    link.style.paddingBottom = "5px"
    link.style.cursor = "pointer"
    link.style.backgroundColor = "var(--color-background)"

    if (dest === initSelected) {
      link.style.backgroundColor = "var(--color-selected)"
    }

    link.addEventListener("mouseover", (event) => {
      if (dest !== globalState.currentDataPage) {
        link.style.backgroundColor = "var(--color-background2)"
      }
    })

    link.addEventListener("mouseout", (event) => {
      if (dest !== globalState.currentDataPage) {
        link.style.background = "var(--color-background)"
      }
    })

    link.addEventListener("click", (event) => {
      for (let child of linksContainer.childNodes) {
        child.style.backgroundColor = "var(--color-background)"
      }
      link.style.backgroundColor = "var(--color-selected)"
      switchDataPage(dest)
    })
  }

  let pageSpecific = addDiv(top)
  pageSpecific.style.marginTop = "20px"

  let bottom = addDiv(sidebar)
  let logout = addDiv(bottom)
  logout.innerHTML = "Logout"
  logout.style.cursor = "pointer"
  logout.addEventListener("mouseover", (event) => logout.style.backgroundColor = "var(--color-selected)")
  logout.addEventListener("mouseleave", (event) => logout.style.backgroundColor = "inherit")
  logout.addEventListener("click", (event) => {
    localStorage.removeItem("password")
    switchToPassword()
  })

  return {sidebar: sidebar, pageSpecific: pageSpecific}
}

const initDataContainer = (sidebarWidthPx) => {
  let container = createDiv()
  container.style.display = "flex"
  container.style.width = `calc(100vw - ${sidebarWidthPx}px)`
  container.style.overflowX = "scroll"
  return container
}

const initSurveys = () => {
  let container = createDiv()
  container.style.display = "flex"

  let surveyDatesFormatters = {default: formatDate, week: (x) => x}
  let surveyDatesColWidths = {default: 100, week: 50}

  let surveyDates2020 = createTableElementFromSoa(
    {
      week: seq(1, 1, 32),
      start: dateSeq("2020-04-06", 7, 32),
      end: dateSeq("2020-04-12", 7, 32),
      send: dateSeq("2020-04-13", 7, 32),
    },
    surveyDatesFormatters,
    surveyDatesColWidths,
    "Weekly survey dates 2020"
  )

  let surveyDates2021 = createTableElementFromSoa(
    {
      week: seq(1, 1, 52),
      start: dateSeq("2021-01-04", 7, 52),
      end: dateSeq("2021-01-10", 7, 52),
      send: dateSeq("2021-01-11", 7, 52),
    },
    surveyDatesFormatters,
    surveyDatesColWidths,
    "Weekly survey dates 2021"
  )

  let surveyDates2022 = createTableElementFromSoa(
    {
      week: seq(1, 1, 52),
      start: dateSeq("2022-01-03", 7, 52),
      end: dateSeq("2022-01-09", 7, 52),
      send: dateSeq("2022-01-10", 7, 52),
    },
    surveyDatesFormatters,
    surveyDatesColWidths,
    "Weekly survey dates 2022"
  )

  let datesContainer = addDiv(container)
  datesContainer.setAttribute("style", tableContainerStyle(surveyDates2022.width))

  let surveys = addDiv(container)
  let completions = addDiv(container)
  return {container: container, surveys: surveys, completions: completions,
    datesContainer: datesContainer,
    datesTables: {2020: surveyDates2020.table, 2021: surveyDates2021.table, 2022: surveyDates2022.table}}
}

const initBleeds = () => {
  let bleeds = createDiv()
  let table = addDiv(bleeds)
  return {bleeds: bleeds, table: table}
}

const initCounts = () => {
  let counts = createDiv()
  let table = addDiv(counts)
  return {counts: counts, table: table}
}

const initCountsSettings = (initGroupsRecords, initGroupsBleeds, initTable) => {
  let container = createDiv()

  let tableSwitch = addEl(container, createSwitch(
    initTable, ["records", "bleeds"],
    (table) => {
      globalState.settings.counts.table = table
      updateCountsTable()
    }
  ))

  let groupSwitchContainer = addDiv(container)

  let recordsSwitch = createSwitch(
    initGroupsRecords,
    ["site", "recruited", "arm", "armCovid",
      "gender", "age", "prior2020", "prior2021", "prior2022"],
    (groups) => {
      globalState.settings.counts.groups_records = groups
      updateCountsTable()
    }
  )
  recordsSwitch.style.marginTop = "20px"

  let bleedsSwitch = createSwitch(
    initGroupsBleeds,
    ["year", "site", "recruited", "arm", "armCovid",
      "gender", "age", "prior2020", "prior2021", "prior2022"],
    (groups) => {
      globalState.settings.counts.groups_bleeds = groups
      updateCountsTable()
    }
  )
  bleedsSwitch.style.marginTop = "20px"

  return {container: container, groupSwitchContainer: groupSwitchContainer,
    recordsSwitch: recordsSwitch, bleedsSwitch: bleedsSwitch}
}

const createCountsRecordsTable = (data, groups) => {

  let withdrawalData = data.withdrawn

  let withdrawals = {}
  for (let row of withdrawalData) {
    if (row.withdrawn === 1 && row.withdrawn_reentered !== 1) {
      withdrawals[row.pid] = true
    }
  }

  let participantData = data.participants

  let groupedCounts = summarise(
    participantData, groups, {total: 0, active: 0},
    (row) => row.pid !== undefined && row.pid.length >= 3,
    (row, group) => {
      let key = null
      switch (group) {
      case "site": {key = row.site;} break
      case "recruited": {key = row.recruitment_year;} break
      case "gender": {key = row.gender;} break
      case "arm": {key = row.arm;} break
      case "armCovid": {key = row.covid_arm;} break
      case "age": {key = row.age_group;} break
      case "prior2020": {key = row.prior2020;} break
      case "prior2021": {key = row.prior2021;} break
      case "prior2022": {key = row.prior2022;} break
      }
      return key
    },
    (row, counts) => {
      let withdrawn = withdrawals[row.pid] === true
      let active = !withdrawn
      counts.total += 1
      if (active) {
        counts.active += 1
      }
    }
  )

  let totalCountsColWidthsPx = {}
  if (groups.length === 0) {
    totalCountsColWidthsPx.Total = 100
  }
  for (let group of groups) {
    totalCountsColWidthsPx[group] = 100
  }
  totalCountsColWidthsPx.total = 100
  totalCountsColWidthsPx.active = 100

  let totalCountsWidthPx = arrSum(Object.values(totalCountsColWidthsPx))

  let totalCountsTableContainer = createDiv()
  totalCountsTableContainer.setAttribute("style", tableContainerStyle(totalCountsWidthPx))

  let countsTableDesc = createDiv()
  addTextline(countsTableDesc, "total - total records in redcap")
  addTextline(countsTableDesc, "active - total records in redcap who are not withdrawn")
  if (groups.length > 0) {
    addTextline(countsTableDesc, "all counts apply to the subset defined by (" + groups.join(", ") + ")")
  }

  for (let group of groups) {
    switch (group) {
    case "recruited": {addTextline(countsTableDesc, "recruited - year the participant was recruited");} break
    case "prior2020": {addTextline(countsTableDesc, "prior2020 - vaccination count between 2015-2019 inclusive");} break
    case "prior2021": {addTextline(countsTableDesc, "prior2021 - vaccination count between 2016-2020 inclusive");} break
    case "prior2022": {addTextline(countsTableDesc, "prior2022 - vaccination count between 2017-2021 inclusive");} break
    }
  }

  let totalCountsTable = createDiv()
  totalCountsTableContainer.appendChild(totalCountsTable)

  let countsTableTitle = "Record counts"
  DOWNLOAD_CSV[countsTableTitle] = Object.keys(totalCountsColWidthsPx).join(",") + "\n"
  totalCountsTable.appendChild(countsTableDesc)
  totalCountsTable.appendChild(createTableTitleElement(countsTableTitle, true))
  totalCountsTable.appendChild(createTableHeaderRowElement(Object.keys(totalCountsColWidthsPx), totalCountsColWidthsPx))

  let groupedCountsFlat = flattenMap(groupedCounts, [])

  let rowsShown = 0

  let tableColNames = Object.keys(totalCountsColWidthsPx)
  for (let rowVals of groupedCountsFlat) {
    let rowElement = createTableRowElement()
    rowsShown += 1
    totalCountsTable.appendChild(rowElement)

    let rowCsv = ""

    for (let rowValIndex = 0; rowValIndex < rowVals.length; rowValIndex += 1) {
      let rowVal = rowVals[rowValIndex]
      rowCsv += "\"" + rowVal + "\""
      if (rowValIndex < rowVals.length - 1) {
        rowCsv += ","
      }
      let colName = tableColNames[rowValIndex]
      let width = totalCountsColWidthsPx[colName]
      rowElement.appendChild(createTableCellStringElement(width, rowVal))
    }

    DOWNLOAD_CSV[countsTableTitle] += rowCsv + "\n"
  }

  totalCountsTable.setAttribute("style", tableContentStyle(totalCountsWidthPx, rowsShown))

  return totalCountsTableContainer
}

const createCountsBleedsTable = (data, groups) => {

  let groupedCounts = summarise(
    data.bleed_dates, groups,
    {fluDay0: 0, fluDay7: 0, fluDay14: 0, fluDay220: 0, covDay0: 0, covDay7: 0, covDay14: 0},
    (row) => true,
    (row, group) => {
      let key = null
      switch (group) {
      case "year": {key = row.year;} break
      case "site": {key = row.site;} break
      case "recruited": {key = row.recruitment_year;} break
      case "gender": {key = row.gender;} break
      case "arm": {key = row.arm;} break
      case "armCovid": {key = row.covid_arm;} break
      case "age": {key = row.age_group;} break
      case "prior2020": {key = row.prior2020;} break
      case "prior2021": {key = row.prior2021;} break
      case "prior2022": {key = row.prior2022;} break
      }
      return key
    },
    (row, counts) => {
      const isPresent = (val) => val !== null && val !== undefined && val !== ""
      if (isPresent(row.flu_day_0)) {counts.fluDay0 += 1}
      if (isPresent(row.flu_day_7)) {counts.fluDay7 += 1}
      if (isPresent(row.flu_day_14)) {counts.fluDay14 += 1}
      if (isPresent(row.flu_day_220)) {counts.fluDay220 += 1}
      if (isPresent(row.covid_day_0)) {counts.covDay0 += 1}
      if (isPresent(row.covid_day_7)) {counts.covDay7 += 1}
      if (isPresent(row.covid_day_14)) {counts.covDay14 += 1}
    }
  )

  let totalCountsColWidthsPx = {}
  if (groups.length === 0) {
    totalCountsColWidthsPx.Total = 100
  }
  for (let group of groups) {
    totalCountsColWidthsPx[group] = 100
  }
  totalCountsColWidthsPx.fluDay0 = 100
  totalCountsColWidthsPx.fluDay7 = 100
  totalCountsColWidthsPx.fluDay14 = 100
  totalCountsColWidthsPx.fluDay220 = 100
  totalCountsColWidthsPx.covDay0 = 100
  totalCountsColWidthsPx.covDay7 = 100
  totalCountsColWidthsPx.covDay14 = 100

  let totalCountsWidthPx = arrSum(Object.values(totalCountsColWidthsPx))

  let totalCountsTableContainer = createDiv()
  totalCountsTableContainer.setAttribute("style", tableContainerStyle(totalCountsWidthPx))

  let countsTableDesc = createDiv()
  addTextline(countsTableDesc, "Bleeds that have a date in redcap")
  if (groups.length > 0) {
    addTextline(countsTableDesc, "all counts apply to the subset defined by (" + groups.join(", ") + ")")
  }

  for (let group of groups) {
    switch (group) {
    case "recruited": {addTextline(countsTableDesc, "recruited - year the participant was recruited");} break
    case "prior2020": {addTextline(countsTableDesc, "prior2020 - vaccination count between 2015-2019 inclusive");} break
    case "prior2021": {addTextline(countsTableDesc, "prior2021 - vaccination count between 2016-2020 inclusive");} break
    case "prior2022": {addTextline(countsTableDesc, "prior2022 - vaccination count between 2017-2021 inclusive");} break
    }
  }

  let totalCountsTable = createDiv()
  totalCountsTableContainer.appendChild(totalCountsTable)

  let countsTableTitle = "Bleed counts"
  DOWNLOAD_CSV[countsTableTitle] = Object.keys(totalCountsColWidthsPx).join(",") + "\n"
  totalCountsTable.appendChild(countsTableDesc)
  totalCountsTable.appendChild(createTableTitleElement(countsTableTitle, true))
  totalCountsTable.appendChild(createTableHeaderRowElement(Object.keys(totalCountsColWidthsPx), totalCountsColWidthsPx))

  let groupedCountsFlat = flattenMap(groupedCounts, [])

  let rowsShown = 0

  let tableColNames = Object.keys(totalCountsColWidthsPx)
  for (let rowVals of groupedCountsFlat) {
    let rowElement = createTableRowElement()
    rowsShown += 1
    totalCountsTable.appendChild(rowElement)

    let rowCsv = ""

    for (let rowValIndex = 0; rowValIndex < rowVals.length; rowValIndex += 1) {
      let rowVal = rowVals[rowValIndex]
      rowCsv += "\"" + rowVal + "\""
      if (rowValIndex < rowVals.length - 1) {
        rowCsv += ","
      }
      let colName = tableColNames[rowValIndex]
      let width = totalCountsColWidthsPx[colName]
      rowElement.appendChild(createTableCellStringElement(width, rowVal))
    }

    DOWNLOAD_CSV[countsTableTitle] += rowCsv + "\n"
  }

  totalCountsTableContainer.setAttribute("style", tableContentStyle(totalCountsWidthPx, rowsShown))

  return totalCountsTableContainer
}

const createBleedsTable = (downloadCsv, data, year) => {
  let bleedsTableContainer = createDiv()

  let allData = data.bleed_dates

  let colWidthsPx = {
    //record_id: 100,
    pid: 100,
    baseline: 100,
    day7: 100,
    day14: 100,
    end: 100,
    day0Covid: 100,
    day7Covid: 100,
    day14Covid: 100,
  }
  let tableWidthPx = arrSum(Object.values(colWidthsPx))
  bleedsTableContainer.setAttribute("style", tableContainerStyle(tableWidthPx))

  let bleedsTable = createDiv()
  bleedsTableContainer.appendChild(bleedsTable)
  let bleedsTableTitle = "Bleed dates"
  bleedsTable.appendChild(createTableTitleElement("Bleed dates", true))
  downloadCsv[bleedsTableTitle] = Object.keys(colWidthsPx).join(",") + "\n"
  bleedsTable.appendChild(createTableHeaderRowElement(Object.keys(colWidthsPx), colWidthsPx))

  let rowsShown = 0
  for (let row of allData) {

    if (row.year === year) {
      const toString = (str) => {
        let result = ""
        if (str !== undefined && str !== null) {
          result = str
        }
        return result
      }

      let dateBaselineBlood = toString(row.flu_day_0)
      let date7dBlood = toString(row.flu_day_7)
      let date14dBlood = toString(row.flu_day_14)
      let dateEndSeasonBlood = toString(row.flu_day_220)
      let dateCovaxBaselineBlood = toString(row.covid_day_0)
      let dateCovax7dBlood = toString(row.covid_day_7)
      let dateCovax14dBlood = toString(row.covid_day_14)

      const notMissing = (val) => val !== "" && val !== undefined && val !== null

      let worthShowing = notMissing(dateBaselineBlood) || notMissing(date7dBlood) || notMissing(date14dBlood) || notMissing(dateEndSeasonBlood)
      if (year > 2020) {
        worthShowing = worthShowing || notMissing(dateCovaxBaselineBlood) || notMissing(dateCovax7dBlood) || notMissing(dateCovax14dBlood)
      }

      if (worthShowing) {
        let rowElement = createTableDataRowElement(rowsShown)
        rowsShown += 1
        bleedsTable.appendChild(rowElement)

        //let recordIdCell = createTableCellStringElement(colWidthsPx.record_id, row.record_id)
        //rowElement.appendChild(recordIdCell)

        let pidCell = createTableCellStringElement(colWidthsPx.pid, row.pid)
        rowElement.appendChild(pidCell)

        let dateBaselineCell = createTableCellStringElement(colWidthsPx.baseline, dateBaselineBlood)
        rowElement.appendChild(dateBaselineCell)

        let day7Cell = createTableCellStringElement(colWidthsPx.day7, date7dBlood)
        rowElement.appendChild(day7Cell)

        let day14Cell = createTableCellStringElement(colWidthsPx.day14, date14dBlood)
        rowElement.appendChild(day14Cell)

        let endCell = createTableCellStringElement(colWidthsPx.end, dateEndSeasonBlood)
        rowElement.appendChild(endCell)

        let rowCsv = row.pid + "," + dateBaselineBlood + "," + date7dBlood + "," + date14dBlood + "," + dateEndSeasonBlood

        if (year > 2020) {
          let day0CovidCell = createTableCellStringElement(colWidthsPx.day0Covid, dateCovaxBaselineBlood)
          rowElement.appendChild(day0CovidCell)

          let day7CovidCell = createTableCellStringElement(colWidthsPx.day7Covid, dateCovax7dBlood)
          rowElement.appendChild(day7CovidCell)

          let day14CovidCell = createTableCellStringElement(colWidthsPx.day14Covid, dateCovax14dBlood)
          rowElement.appendChild(day14CovidCell)

          rowCsv += "," + dateCovaxBaselineBlood + "," + dateCovax7dBlood + "," + dateCovax14dBlood
        }

        rowCsv += "\n"
        downloadCsv[bleedsTableTitle] += rowCsv
      }
    }
  }

  bleedsTable.setAttribute("style", tableContentStyle(tableWidthPx, rowsShown))
  return bleedsTableContainer
}

const createSurveyTable = (completions, data, year) => {
  let tableContainer = createDiv()
  let table = addDiv(tableContainer)

  let allData = data.weekly_surveys

  let colWidthsPx = {
    pid: 100,
    week: 100,
    completed: 100,
    ari: 100,
  }
  let tableWidthPx = arrSum(Object.values(colWidthsPx))
  tableContainer.setAttribute(
    "style", tableContainerStyle(tableWidthPx)
  )

  table.appendChild(createTableTitleElement("Completed weekly surveys"))
  table.appendChild(createTableHeaderRowElement(Object.keys(colWidthsPx), colWidthsPx))

  let rowsShown = 0
  for (let row of allData) {

    if (row.year == year) {

      let completed = row.complete
      if (completed !== 0) {

        let week = row.survey_index

        let rowElement = createTableDataRowElement(rowsShown)
        rowsShown += 1
        table.appendChild(rowElement)

        let pidCell = createTableCellStringElement(colWidthsPx.pid, row.pid)
        rowElement.appendChild(pidCell)

        let weekCell = createTableCellStringElement(colWidthsPx.week, week)
        rowElement.appendChild(weekCell)

        let completedCell = createTableCellStringElement(colWidthsPx.completed, completed)
        rowElement.appendChild(completedCell)

        let ari = row.ari
        let ariCell = createTableCellStringElement(colWidthsPx.ari, ari)
        rowElement.appendChild(ariCell)

        if (completions[row.pid] === undefined) {
          completions[row.pid] = []
        }
        completions[row.pid].push(week)

      }
    }
  }
  table.setAttribute("style", tableContentStyle(tableWidthPx, rowsShown))

  return tableContainer
}

const createCompletionsTable = (completions) => {

  let tableContainer = createDiv()
  let table = addDiv(tableContainer)

  let rows = Object.entries(completions)

  let colWidthsPx = {
    pid: 100,
    completions: 300,
  }
  let tableWidthPx = arrSum(Object.values(colWidthsPx))
  table.setAttribute("style", tableContentStyle(tableWidthPx, rows.length))
  tableContainer.setAttribute(
    "style", tableContainerStyle(tableWidthPx)
  )

  table.appendChild(createTableTitleElement("Weekly completions"))
  table.appendChild(createTableHeaderRowElement(Object.keys(colWidthsPx), colWidthsPx))

  let rowsShown = 0
  for (let [record, completedSurveys] of rows) {
    let rowElement = createTableDataRowElement(rowsShown)
    table.appendChild(rowElement)
    rowsShown += 1

    rowElement.appendChild(createTableCellStringElement(colWidthsPx.pid, record))

    let collapsedCompletions = ""
    if (completedSurveys.length > 0) {
      collapsedCompletions += completedSurveys[0]
      if (completedSurveys.length > 1) {

        let prev = completedSurveys[0]
        let currentStreak = 1
        for (let completeIndex = 1; completeIndex < completedSurveys.length; completeIndex += 1) {
          let compl = completedSurveys[completeIndex]

          if (completeIndex == completedSurveys.length - 1) {

            if (currentStreak > 1) {
              collapsedCompletions += "-"
            } else {
              collapsedCompletions += ", "
            }
            collapsedCompletions += compl

          } else if (compl - prev == currentStreak) {

            currentStreak += 1

          } else {

            if (currentStreak > 1) {
              let lastNotShown = prev + currentStreak - 1
              collapsedCompletions += "-" + lastNotShown
            }

            collapsedCompletions += ", "
            collapsedCompletions += compl
            currentStreak = 1
            prev = compl
          }

        }
      }
    }

    rowElement.appendChild(createTableCellStringElement(colWidthsPx.completions, collapsedCompletions))
  }

  return tableContainer
}

const fetchData = async (password) => {
  let success = true
  let data = {}

  if (
    password === "" ||
    password === null ||
    password === undefined ||
    !(typeof password === "string" || password instanceof String)
  ) {

    success = false

  } else {

    let address =
      "https://reports2.hcwflustudy.com/api2/" +
      password +
      "/data.json"

    //address = `/pull-redcap/redcap-all_data.json`

    try {
      let resp = await fetch(address)
      data = await resp.json()
    } catch (e) {
      success = false
      console.error(e)
    }
  }

  return {success: success, data: data}
}

const SIDEBAR_WIDTH_PX = 80
const INIT_DATA_PAGE = "weeklySurveys"
const INIT_YEAR = 2022
const YEARS = [2020, 2021, 2022]
const INIT_GROUPS_RECORDS = ["site"]
const INIT_GROUPS_BLEEDS = ["year"]
const INIT_COUNT_TABLE = "records"
const DOWNLOAD_CSV = {}

let globalState = {
  data: {},

  domMain: document.getElementById("main"),
  currentDataPage: INIT_DATA_PAGE,

  elements: {
    loading: initLoading(),
    password: initPassword(),

    sidebar: initSidebar(SIDEBAR_WIDTH_PX, INIT_DATA_PAGE),

    weeklySurveySettings: createSwitch(
      INIT_YEAR, YEARS,
      (year) => {
        globalState.settings.weeklySurveys.year = year
        updateSurveyTables()
      }
    ),

    bleedsSettings: createSwitch(
      INIT_YEAR, YEARS,
      (year) => {
        globalState.settings.bleeds.year = year
        updateBleedsTable()
      }
    ),

    countsSettings: initCountsSettings(INIT_GROUPS_RECORDS, INIT_GROUPS_BLEEDS, INIT_COUNT_TABLE),

    dataContainer: initDataContainer(SIDEBAR_WIDTH_PX),
    weeklySurveys: initSurveys(),
    bleeds: initBleeds(),
    counts: initCounts(),
  },

  settings: {
    weeklySurveys: { year: 2022 },
    bleeds: { year: 2022 },
    counts: { groups_records: INIT_GROUPS_RECORDS, groups_bleeds: INIT_GROUPS_BLEEDS,
      table: INIT_COUNT_TABLE },
  },
}

const switchDataPage = (name) => {
  let oldDataPage = globalState.currentDataPage
  globalState.currentDataPage = name
  switch (name) {
  case "weeklySurveys": {
    replaceChildren(globalState.elements.sidebar.pageSpecific, globalState.elements.weeklySurveySettings)
    replaceChildren(globalState.elements.dataContainer, globalState.elements.weeklySurveys.container)
  } break
  case "bleeds": {
    replaceChildren(globalState.elements.sidebar.pageSpecific, globalState.elements.bleedsSettings)
    replaceChildren(globalState.elements.dataContainer, globalState.elements.bleeds.bleeds)
  } break
  case "counts": {
    replaceChildren(globalState.elements.sidebar.pageSpecific, globalState.elements.countsSettings.container)
    replaceChildren(globalState.elements.dataContainer, globalState.elements.counts.counts)
  } break
  default: {
    console.error("data page", name, "does not exist")
    globalState.currentDataPage = oldDataPage
  }
  }
}

const switchToPassword = () => replaceChildren(globalState.domMain, globalState.elements.password)
const switchToLoading = () => replaceChildren(globalState.domMain, globalState.elements.loading)
const switchToData = (dataPageName) => {
  removeChildren(globalState.domMain)
  addEl(globalState.domMain, globalState.elements.sidebar.sidebar)
  addEl(globalState.domMain, globalState.elements.dataContainer)
  switchDataPage(dataPageName)
}

const updateCountsTable = () => {
  let tableEl = createDiv()
  let switchEl = createDiv()

  switch (globalState.settings.counts.table) {
  case "records": {
      tableEl = createCountsRecordsTable(globalState.data, globalState.settings.counts.groups_records)
      switchEl = globalState.elements.countsSettings.recordsSwitch
  } break;
  case "bleeds": {
      tableEl = createCountsBleedsTable(globalState.data, globalState.settings.counts.groups_bleeds)
      switchEl = globalState.elements.countsSettings.bleedsSwitch
  } break;
  default: console.error("unexpected counts table name", globalState.settings.counts.table)
  }

  replaceChildren(globalState.elements.counts.table, tableEl)
  replaceChildren(globalState.elements.countsSettings.groupSwitchContainer, switchEl)
}

const updateBleedsTable = () => replaceChildren(
  globalState.elements.bleeds.table,
  createBleedsTable(DOWNLOAD_CSV, globalState.data, globalState.settings.bleeds.year)
)

const updateSurveyTables = () => {
  replaceChildren(
    globalState.elements.weeklySurveys.datesContainer,
    globalState.elements.weeklySurveys.datesTables[globalState.settings.weeklySurveys.year]
  )
  let completions = {}
  replaceChildren(
    globalState.elements.weeklySurveys.surveys,
    createSurveyTable(completions, globalState.data, globalState.settings.weeklySurveys.year)
  )
  replaceChildren(
    globalState.elements.weeklySurveys.completions,
    createCompletionsTable(completions)
  )
}

// NOTE(sen) Attempt to login from local storage
{
  let password = localStorage.getItem("password")
  if (password === null) {
    switchToPassword()
  } else {
    switchToLoading()
    let fetchResult = await fetchData(password)
    if (!fetchResult.success) {
      switchToPassword()
    } else {
      globalState.data = fetchResult.data
      updateCountsTable()
      updateBleedsTable()
      updateSurveyTables()
      switchToData(globalState.currentDataPage)
    }
  }
}

// TODO(sen) Paths
// TODO(sen) Download all tables (current: bleed, counts, survey dates)
// TODO(sen) Table filtering
// TODO(sen) Table with emails and sites
// TODO(sen) Correct height for tables with descriptions
  </script>
</html>
